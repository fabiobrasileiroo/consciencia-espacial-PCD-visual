#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const ExcelJS = require('exceljs');
const simpleGit = require('simple-git');

const repoRoot = path.resolve(__dirname, '..', '..'); // /docs/change-management/.. => repo root
const changeManagementFolder = path.resolve(__dirname, '..');
const git = simpleGit(repoRoot);

// Config
const outFile = path.join(changeManagementFolder, 'CHANGE_MANAGEMENT_AUTOGENERATED.xlsx');
const overwriteTemplates = process.argv.includes('--overwrite');

// Utilities
async function findPackageJsonFiles(root) {
  const results = [];
  const ignoreDirs = new Set(['node_modules', 'venv', '.git', '.venv', '.cache', 'dist', 'build']);
  async function walk(dir) {
    const list = await fs.promises.readdir(dir, { withFileTypes: true });
    for (const dirent of list) {
      const full = path.join(dir, dirent.name);
      if (dirent.isDirectory()) {
        if (!ignoreDirs.has(dirent.name)) {
          await walk(full);
        }
      } else if (dirent.isFile() && dirent.name === 'package.json') {
        // skip top-level 'docs/change-management/automation/package.json'
        if (!full.startsWith(changeManagementFolder)) {
          results.push(full);
        }
      }
    }
  }
  await walk(root);
  return results;
}

async function gatherData() {
  // Gather repo metadata
  const repoName = path.basename(repoRoot);
  const branch = (await git.revparse(['--abbrev-ref', 'HEAD'])).trim();
  const latestCommit = await git.log({ n: 1 });
  const latest = latestCommit.all[0] || {};
  const contributors = (await git.raw(['shortlog', '-sne'])).split('\n').filter(Boolean).map(line => {
    const parts = line.trim().split('\t').filter(Boolean);
    const nameEmail = parts[1] || '';
    const m = nameEmail.match(/(.*) <(.*)>/);
    if (m) {
      return { commits: parts[0].trim(), name: m[1].trim(), email: m[2].trim() };
    }
    return { commits: parts[0].trim(), name: nameEmail, email: '' };
  });

  // Get commits (last 200)
  const commits = (await git.log({ n: 200 })).all.map(c => ({ hash: c.hash, date: c.date, message: c.message, author: c.author_name, email: c.author_email }));

  // Get tags
  const tags = (await git.tags()).all;

  // Find all package.json files
  const packageFiles = await findPackageJsonFiles(repoRoot);
  const packages = [];
  for (const p of packageFiles) {
    try {
      const raw = await fs.promises.readFile(p, 'utf8');
      const json = JSON.parse(raw);
      packages.push({ name: json.name || path.basename(path.dirname(p)), version: json.version || '', path: path.relative(repoRoot, p), dependencies: json.dependencies || {}, devDependencies: json.devDependencies || {} });
    } catch (e) {
      console.warn('Failed to parse', p, e.message);
    }
  }

  // Get files changed in last 30 days
  const since = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  const recentCommits = (await git.log({ since: since.toISOString() })).all;
  const changedFilesSet = new Set();
  for (const c of recentCommits) {
    const diff = await git.show(['--name-only', '--pretty=', c.hash]);
    diff.split('\n').filter(Boolean).forEach(f => changedFilesSet.add(f));
  }
  const changedFiles = Array.from(changedFilesSet);

  return { repoName, branch, latest, contributors, commits, tags, packages, changedFiles };
}

async function writeWorkbook(data) {
  const w = new ExcelJS.Workbook();
  w.creator = 'Change Management Automation';
  w.created = new Date();

  // PLANEJAMENTO: Project overview
  const planning = w.addWorksheet('PLANEJAMENTO');
  planning.addRow(['Repository', data.repoName]);
  planning.addRow(['Branch', data.branch]);
  planning.addRow(['Latest Commit', data.latest.hash || '']);
  planning.addRow(['Latest Commit Date', data.latest.date || '']);
  planning.addRow(['Latest Commit Author', data.latest.author || '']);
  planning.addRow(['Tags', data.tags.join(', ')]);
  planning.addRow(['Generated On', new Date().toISOString()]);

  // REQUISITOS: We'll list package metadata and basic requirements
  const req = w.addWorksheet('REQUISITOS');
  req.addRow(['Package Name', 'Version', 'Path']);
  data.packages.forEach(p => req.addRow([p.name, p.version, p.path]));

  // RFC REQUESTS: list commits (as potential change requests)
  const rfc = w.addWorksheet('RFC REQUESTS');
  rfc.addRow(['Hash', 'Date', 'Author', 'Message']);
  data.commits.forEach(c => rfc.addRow([c.hash, c.date, c.author, c.message]));

  // TRIAGEM: changed files in last 30 days
  const triage = w.addWorksheet('TRIAGEM');
  triage.addRow(['Changed Files (30 days)']);
  data.changedFiles.forEach(f => triage.addRow([f]));

  // APROVAÇÃO CCB: contributors
  const ccb = w.addWorksheet('APROVAÇÃO CCB');
  ccb.addRow(['Name', 'Email', 'Commits']);
  data.contributors.forEach(c => ccb.addRow([c.name, c.email, c.commits]));

  // ANÁLISE IMPACTO: files with details and sizes
  const impact = w.addWorksheet('ANÁLISE IMPACTO');
  impact.addRow(['File', 'Size (bytes)', 'Path']);
  for (const f of data.changedFiles) {
    try {
      const st = await fs.promises.stat(path.join(repoRoot, f));
      impact.addRow([path.basename(f), st.size, f]);
    } catch (e) {
      impact.addRow([path.basename(f), 'n/a', f]);
    }
  }

  // VALIDAÇÃO: maybe tests and script existence
  const val = w.addWorksheet('VALIDAÇÃO');
  val.addRow(['Package', 'HasTestScript']);
  data.packages.forEach(p => {
    try {
      // read script from package.json
      const full = path.join(repoRoot, p.path);
      const pkg = JSON.parse(fs.readFileSync(full, 'utf8'));
      const hasTest = pkg.scripts && pkg.scripts.test ? 'yes' : 'no';
      val.addRow([p.name, hasTest]);
    } catch (e) {
      val.addRow([p.name, 'unknown']);
    }
  });

  // ENCERRAMENTO: closure info like last commit message and summary
  const close = w.addWorksheet('ENCERRAMENTO');
  close.addRow(['Latest Commit', data.latest.hash || '']);
  close.addRow(['Latest Commit Date', data.latest.date || '']);
  close.addRow(['Latest Commit Author', data.latest.author || '']);
  close.addRow(['Latest Commit Message', data.latest.message || '']);

  await w.xlsx.writeFile(outFile);
  console.log('Written to', outFile);

  if (overwriteTemplates) {
    const templates = ['PLANEJAMENTO.xlsx', 'REQUISITOS.xlsx', 'RFC REQUESTS.xlsx', 'TRIAGEM.xlsx', 'APROVAÇÃO CCB.xlsx', 'ANÁLISE IMPACTO.xlsx', 'VALIDAÇÃO.xlsx', 'ENCERRAMENTO.xlsx'];
    for (const t of templates) {
      const targetPath = path.join(changeManagementFolder, t);
      try {
        await w.xlsx.writeFile(targetPath);
        console.log('Overwrote template', targetPath);
      } catch (e) {
        console.warn('Failed to overwrite', t, e.message);
      }
    }
  }
}

(async () => {
  try {
    console.log('Gathering data...');
    const data = await gatherData();
    console.log('Writing workbook...');
    await writeWorkbook(data);
    console.log('Done.');
  } catch (err) {
    console.error('Error:', err);
    process.exit(1);
  }
})();
