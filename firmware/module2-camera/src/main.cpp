#include <Arduino.h>
#include "esp_camera.h"
#include <WiFi.h>
#include <SocketIOclient.h>
#include <ArduinoJson.h>
#include "esp_timer.h"
#include "img_converters.h"

using namespace ArduinoJson;

// ===== CONFIGURA√á√ïES WIFI & SERVIDOR =====
const char* ssid = "FJ";
const char* password = "#f39A@jl32*1";
const char* serverIP = "192.168.100.11"; // IP do servidor
const int serverPort = 3000;
const char* MODULE_ID = "ESP32_CAM_MODULE2"; // ID √∫nico deste m√≥dulo

// ===== DECLARA√á√ïES FORWARD =====
void webSocketEvent(socketIOmessageType_t type, uint8_t * payload, size_t length);
void registerESP32();
void handleWebSocketMessage(char* payload);
void handleCommand(JsonObject commandData);
void sendStatusReport();
bool sendToServerWebSocket(const String& description, camera_fb_t *fb, 
                           unsigned long captureTime, unsigned long detectionTime, 
                           unsigned long sendTime);

// ===== CONFIGURA√á√ÉO DOS PINOS DA C√ÇMERA ESP32-S3 =====
#define PWDN_GPIO_NUM     -1
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM     15
#define SIOD_GPIO_NUM     4
#define SIOC_GPIO_NUM     5
#define Y9_GPIO_NUM       16
#define Y8_GPIO_NUM       17
#define Y7_GPIO_NUM       18
#define Y6_GPIO_NUM       12
#define Y5_GPIO_NUM       10
#define Y4_GPIO_NUM       8
#define Y3_GPIO_NUM       9
#define Y2_GPIO_NUM       11
#define VSYNC_GPIO_NUM    6
#define HREF_GPIO_NUM     7
#define PCLK_GPIO_NUM     13

// ===== CLASSES DE OBJETOS DETECT√ÅVEIS (COCO Dataset) =====
const char* OBJECT_CLASSES[] = {
  "pessoa", "bicicleta", "carro", "moto", "avi√£o", "√¥nibus", "trem", "caminh√£o", 
  "barco", "sem√°foro", "hidrante", "placa_pare", "parqu√≠metro", "banco", 
  "p√°ssaro", "gato", "cachorro", "cavalo", "ovelha", "vaca", "elefante", "urso", 
  "zebra", "girafa", "mochila", "guarda-chuva", "bolsa", "gravata", "mala", 
  "frisbee", "esqui", "snowboard", "bola", "pipa", "taco_baseball", "luva_baseball", 
  "skate", "prancha_surf", "raquete_tenis", "garrafa", "ta√ßa_vinho", "x√≠cara", 
  "garfo", "faca", "colher", "tigela", "banana", "ma√ß√£", "sandu√≠che", "laranja", 
  "br√≥colis", "cenoura", "cachorro-quente", "pizza", "donut", "bolo", "cadeira", 
  "sof√°", "vaso_planta", "cama", "mesa_jantar", "vaso_sanit√°rio", "tv", 
  "laptop", "mouse", "controle_remoto", "teclado", "celular", "microondas", 
  "forno", "torradeira", "pia", "geladeira", "livro", "rel√≥gio", "vaso", 
  "tesoura", "urso_pel√∫cia", "secador_cabelo", "escova_dente"
};

const int NUM_CLASSES = sizeof(OBJECT_CLASSES) / sizeof(OBJECT_CLASSES[0]);

// ===== ESTRUTURA PARA DETEC√á√ïES =====
struct Detection {
  int classId;
  float confidence;
  int x, y, width, height;
};

// ===== VARI√ÅVEIS GLOBAIS =====
SocketIOclient socketIO;
unsigned long lastDetectionTime = 0;
const unsigned long DETECTION_INTERVAL = 3000; // Detec√ß√£o a cada 3 segundos
bool wifiConnected = false;
bool cameraOK = false; // Flag para indicar se c√¢mera est√° funcionando
bool websocketConnected = false;
bool isRegistered = false;

// Vari√°veis de configura√ß√£o (controladas remotamente)
int currentFPS = 10;
String currentResolution = "QVGA";
float confidenceThreshold = 0.7;
String operationMode = "continuous";

// ===== FUN√á√ÉO: INICIALIZAR C√ÇMERA =====
bool initCamera() {
  Serial.println("\nüîß === INICIANDO CONFIGURA√á√ÉO DA C√ÇMERA ===");
  Serial.println("üîß Configurando pinos da c√¢mera...");
  
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  config.grab_mode = CAMERA_GRAB_LATEST;

  Serial.println("‚úÖ Pinos configurados!");
  Serial.println("üîß Configurando mem√≥ria e resolu√ß√£o...");
  
  // Configura√ß√µes otimizadas COM PSRAM
  if(psramFound()){
    Serial.println("‚úÖ PSRAM detectado! Usando alta resolu√ß√£o");
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.frame_size = FRAMESIZE_QVGA; // 320x240 - Boa qualidade com PSRAM
    config.jpeg_quality = 10; // Melhor qualidade
    config.fb_count = 2; // 2 buffers para melhor performance
  } else {
    Serial.println("‚ö†Ô∏è  PSRAM n√£o detectado! Usando DRAM");
    config.fb_location = CAMERA_FB_IN_DRAM;
    config.frame_size = FRAMESIZE_QQVGA; // 160x120 - Fallback
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }

  Serial.println("üîß Inicializando driver da c√¢mera...");
  
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("‚ùå ERRO ao inicializar c√¢mera: 0x%x\n", err);
    Serial.println("‚ùå C√≥digo do erro:");
    switch(err) {
      case ESP_ERR_INVALID_ARG:
        Serial.println("   - Argumento inv√°lido");
        break;
      case ESP_ERR_NO_MEM:
        Serial.println("   - Sem mem√≥ria dispon√≠vel");
        break;
      case ESP_ERR_NOT_FOUND:
        Serial.println("   - C√¢mera n√£o encontrada");
        break;
      default:
        Serial.println("   - Erro desconhecido");
    }
    return false;
  }

  Serial.println("üîß Configurando sensor...");
  
  // Otimizar sensor para detec√ß√£o
  sensor_t * s = esp_camera_sensor_get();
  if (s != NULL) {
    s->set_brightness(s, 0);
    s->set_contrast(s, 0);
    s->set_saturation(s, 0);
    s->set_whitebal(s, 1);
    s->set_awb_gain(s, 1);
    s->set_exposure_ctrl(s, 1);
    s->set_aec2(s, 1);
    s->set_gain_ctrl(s, 1);
    s->set_agc_gain(s, 0);
    s->set_bpc(s, 1);
    s->set_wpc(s, 1);
    s->set_raw_gma(s, 1);
    s->set_lenc(s, 1);
    s->set_hmirror(s, 0);
    s->set_vflip(s, 0);
    Serial.println("‚úÖ Sensor configurado!");
  } else {
    Serial.println("‚ö†Ô∏è  Aviso: N√£o foi poss√≠vel acessar configura√ß√µes do sensor");
  }

  Serial.println("‚úÖ C√¢mera inicializada com sucesso!");
  cameraOK = true; // Marca que c√¢mera est√° OK
  return true;
}

// ===== FUN√á√ÉO: DETEC√á√ÉO SIMULADA (PLACEHOLDER) =====
// NOTA: Aqui voc√™ integraria um modelo TFLite ou usaria API externa
String detectObjectsAndDescribe(camera_fb_t *fb) {
  // Esta √© uma implementa√ß√£o simulada
  // Na vers√£o real, voc√™ usaria:
  // 1. TensorFlow Lite Micro para infer√™ncia local
  // 2. Edge Impulse para modelo otimizado
  // 3. API externa (Google Vision, AWS Rekognition, Roboflow)
  
  Serial.println("üîç Analisando imagem...");
  
  // Simula√ß√£o de detec√ß√£o (remova em produ√ß√£o)
  Detection detections[3];
  int numDetections = 0;
  
  // Simula√ß√£o: detecta objetos aleat√≥rios
  if (random(0, 100) > 30) {
    detections[numDetections++] = {0, 0.95, 10, 20, 100, 150}; // pessoa
  }
  if (random(0, 100) > 60) {
    detections[numDetections++] = {56, 0.87, 120, 80, 80, 60}; // cadeira
  }
  if (random(0, 100) > 70) {
    detections[numDetections++] = {73, 0.92, 200, 150, 50, 40}; // livro
  }
  
  // Construir descri√ß√£o em portugu√™s
  String description = "";
  
  if (numDetections == 0) {
    description = "Nenhum objeto detectado na cena";
  } else {
    description = "Detectado ";
    description += String(numDetections);
    description += (numDetections == 1) ? " objeto: " : " objetos: ";
    
    for (int i = 0; i < numDetections; i++) {
      int classId = detections[i].classId;
      float conf = detections[i].confidence;
      
      if (classId < NUM_CLASSES) {
        description += OBJECT_CLASSES[classId];
        description += " (";
        description += String((int)(conf * 100));
        description += "%)";
        
        if (i < numDetections - 1) {
          description += ", ";
        }
      }
    }
    
    // Adicionar contexto espacial
    description += ". ";
    if (detections[0].x < 100) {
      description += "√† esquerda";
    } else if (detections[0].x > 220) {
      description += "√† direita";
    } else {
      description += "ao centro";
    }
  }
  
  return description;
}

// ===== FUN√á√ÉO: CALLBACK WEBSOCKET =====
void webSocketEvent(socketIOmessageType_t type, uint8_t * payload, size_t length) {
  switch(type) {
    case sIOtype_DISCONNECT:
      Serial.println("‚ùå Desconectado do servidor WebSocket");
      websocketConnected = false;
      isRegistered = false;
      break;
      
    case sIOtype_CONNECT:
      Serial.println("‚úÖ Conectado ao servidor WebSocket");
      websocketConnected = true;
      registerESP32();
      break;
      
    case sIOtype_EVENT:
      handleWebSocketMessage((char*)payload);
      break;
      
    case sIOtype_ACK:
      Serial.println("üì¨ ACK recebido do servidor");
      break;
      
    case sIOtype_ERROR:
      Serial.printf("‚ùå Erro WebSocket: %s\n", payload);
      websocketConnected = false;
      break;
  }
}

// ===== FUN√á√ÉO: REGISTRAR ESP32 NO SERVIDOR =====
void registerESP32() {
  if (!websocketConnected) return;
  
  JsonDocument doc;
  JsonArray array = doc.to<JsonArray>();
  
  array.add("register_esp32");
  
  JsonObject param = array.add<JsonObject>();
  param["moduleId"] = MODULE_ID;
  
  String output;
  serializeJson(doc, output);
  
  socketIO.sendEVENT(output);
  Serial.println("üì° Registro enviado ao servidor");
}

// ===== FUN√á√ÉO: PROCESSAR MENSAGENS WEBSOCKET =====
void handleWebSocketMessage(char* payload) {
  JsonDocument doc;
  DeserializationError error = deserializeJson(doc, payload);
  
  if (error) {
    Serial.println("‚ùå Erro ao parsear JSON do WebSocket");
    return;
  }
  
  // Pegar o nome do evento
  const char* eventName = doc[0];
  
  if (strcmp(eventName, "connected") == 0) {
    Serial.println("‚úÖ Confirma√ß√£o de conex√£o recebida");
    return;
  }
  
  if (strcmp(eventName, "registered") == 0) {
    Serial.println("‚úÖ ESP32 registrado com sucesso no servidor!");
    isRegistered = true;
    JsonObject data = doc[1];
    Serial.print("üìç Module ID: ");
    Serial.println(data["moduleId"].as<String>());
    return;
  }
  
  if (strcmp(eventName, "detection_ack") == 0) {
    JsonObject data = doc[1];
    Serial.print("‚úÖ Detec√ß√£o confirmada pelo servidor - ID: ");
    Serial.println(data["detectionId"].as<String>());
    return;
  }
  
  if (strcmp(eventName, "command") == 0) {
    JsonObject data = doc[1];
    handleCommand(data);
    return;
  }
  
  Serial.print("üì® Evento desconhecido: ");
  Serial.println(eventName);
}

// ===== FUN√á√ÉO: PROCESSAR COMANDOS DO SERVIDOR =====
void handleCommand(JsonObject commandData) {
  const char* command = commandData["command"];
  JsonObject data = commandData["data"];
  
  Serial.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  Serial.println("‚ïë            üì• COMANDO RECEBIDO DO SERVIDOR            ‚ïë");
  Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
  Serial.print("üéØ Comando: ");
  Serial.println(command);
  
  if (strcmp(command, "setFPS") == 0) {
    int newFPS = data["fps"];
    if (newFPS >= 1 && newFPS <= 30) {
      currentFPS = newFPS;
      Serial.printf("‚úÖ FPS ajustado para: %d\n", currentFPS);
      // Atualizar intervalo de detec√ß√£o
      // DETECTION_INTERVAL seria recalculado aqui
    } else {
      Serial.println("‚ùå FPS inv√°lido (deve ser 1-30)");
    }
  }
  
  else if (strcmp(command, "setResolution") == 0) {
    const char* resolution = data["resolution"];
    currentResolution = String(resolution);
    Serial.printf("‚úÖ Resolu√ß√£o alterada para: %s\n", resolution);
    
    // Aplicar mudan√ßa de resolu√ß√£o na c√¢mera
    sensor_t * s = esp_camera_sensor_get();
    if (s != NULL) {
      if (strcmp(resolution, "QQVGA") == 0) {
        s->set_framesize(s, FRAMESIZE_QQVGA); // 160x120
      } else if (strcmp(resolution, "QVGA") == 0) {
        s->set_framesize(s, FRAMESIZE_QVGA); // 320x240
      } else if (strcmp(resolution, "VGA") == 0) {
        s->set_framesize(s, FRAMESIZE_VGA); // 640x480
      } else if (strcmp(resolution, "SVGA") == 0) {
        s->set_framesize(s, FRAMESIZE_SVGA); // 800x600
      }
      Serial.println("üì∏ Resolu√ß√£o da c√¢mera atualizada!");
    }
  }
  
  else if (strcmp(command, "setThreshold") == 0) {
    float threshold = data["threshold"];
    if (threshold >= 0.0 && threshold <= 1.0) {
      confidenceThreshold = threshold;
      Serial.printf("‚úÖ Threshold de confian√ßa ajustado para: %.2f\n", confidenceThreshold);
    } else {
      Serial.println("‚ùå Threshold inv√°lido (deve ser 0.0-1.0)");
    }
  }
  
  else if (strcmp(command, "toggleMode") == 0) {
    const char* mode = data["mode"];
    operationMode = String(mode);
    Serial.printf("‚úÖ Modo de opera√ß√£o alterado para: %s\n", mode);
  }
  
  else if (strcmp(command, "reboot") == 0) {
    Serial.println("üîÑ Reiniciando ESP32 em 3 segundos...");
    delay(3000);
    ESP.restart();
  }
  
  else if (strcmp(command, "calibrate") == 0) {
    Serial.println("üîß Calibrando sensores da c√¢mera...");
    sensor_t * s = esp_camera_sensor_get();
    if (s != NULL) {
      // Reset para configura√ß√µes padr√£o
      s->set_brightness(s, 0);
      s->set_contrast(s, 0);
      s->set_saturation(s, 0);
      Serial.println("‚úÖ Calibra√ß√£o conclu√≠da!");
    }
  }
  
  else if (strcmp(command, "getStatus") == 0) {
    Serial.println("üìä Enviando status ao servidor...");
    sendStatusReport();
  }
  
  else {
    Serial.printf("‚ùì Comando desconhecido: %s\n", command);
  }
  
  Serial.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n");
}

// ===== FUN√á√ÉO: ENVIAR STATUS PARA SERVIDOR =====
void sendStatusReport() {
  if (!websocketConnected || !isRegistered) {
    Serial.println("‚ö†Ô∏è  WebSocket n√£o conectado, n√£o √© poss√≠vel enviar status");
    return;
  }
  
  JsonDocument doc;
  JsonArray array = doc.to<JsonArray>();
  
  array.add("status_report");
  
  JsonObject status = array.add<JsonObject>();
  status["moduleId"] = MODULE_ID;
  status["fps"] = currentFPS;
  status["resolution"] = currentResolution;
  status["threshold"] = confidenceThreshold;
  status["mode"] = operationMode;
  status["freeHeap"] = ESP.getFreeHeap();
  status["rssi"] = WiFi.RSSI();
  status["uptime"] = millis() / 1000;
  status["cameraOK"] = cameraOK;
  
  String output;
  serializeJson(doc, output);
  
  socketIO.sendEVENT(output);
  Serial.println("üìä Status enviado ao servidor");
}

// ===== FUN√á√ÉO: ENVIAR DETEC√á√ÉO VIA WEBSOCKET =====
bool sendToServerWebSocket(const String& description, camera_fb_t *fb, 
                           unsigned long captureTime, unsigned long detectionTime, 
                           unsigned long sendTime) {
  if (!websocketConnected || !isRegistered) {
    Serial.println("‚ö†Ô∏è  WebSocket n√£o conectado ou n√£o registrado");
    return false;
  }
  
  JsonDocument doc;
  JsonArray array = doc.to<JsonArray>();
  
  array.add("detection");
  
  JsonObject payload = array.add<JsonObject>();
  payload["moduleId"] = MODULE_ID;
  payload["timestamp"] = millis();
  
  // Array de objetos detectados (simula√ß√£o)
  JsonArray objects = payload["objects"].to<JsonArray>();
  
  // Exemplo: pessoa detectada
  JsonObject obj1 = objects.add<JsonObject>();
  obj1["name"] = "pessoa";
  obj1["confidence"] = 0.85;
  obj1["description"] = description;
  
  // M√©tricas do sistema
  JsonObject metrics = payload["metrics"].to<JsonObject>();
  metrics["captureTime"] = captureTime;
  metrics["detectionTime"] = detectionTime;
  metrics["sendTime"] = sendTime;
  metrics["totalTime"] = captureTime + detectionTime + sendTime;
  metrics["freeHeap"] = ESP.getFreeHeap();
  metrics["rssi"] = WiFi.RSSI();
  metrics["fps"] = currentFPS;
  
  String output;
  serializeJson(doc, output);
  
  socketIO.sendEVENT(output);
  
  Serial.println("üì§ Detec√ß√£o enviada via WebSocket");
  return true;
}

// ===== FUN√á√ÉO: ENVIAR PARA SERVIDOR (MANTIDA PARA COMPATIBILIDADE) =====
bool sendToServer(const String& description, camera_fb_t *fb) {
  // Redirecionar para WebSocket se conectado
  if (websocketConnected && isRegistered) {
    return sendToServerWebSocket(description, fb, 0, 0, 0);
  }
  
  Serial.println("‚ö†Ô∏è  WebSocket n√£o dispon√≠vel");
  return false;
}

// ===== FUN√á√ÉO: PROCESSAR FRAME =====
void processFrame() {
  unsigned long startTime = millis();
  uint32_t freeHeapBefore = ESP.getFreeHeap();
  
  camera_fb_t *fb = esp_camera_fb_get();
  
  if (!fb) {
    Serial.println("‚ùå Falha ao capturar frame");
    return;
  }
  
  unsigned long captureTime = millis() - startTime;
  
  Serial.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  Serial.println("‚ïë            üì∏ NOVA CAPTURA E AN√ÅLISE                  ‚ïë");
  Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
  Serial.printf("üì∏ Frame: %dx%d (%d bytes) - Captura: %lu ms\n", 
                fb->width, fb->height, fb->len, captureTime);
  
  // Detectar objetos e gerar descri√ß√£o
  unsigned long detectionStart = millis();
  String description = detectObjectsAndDescribe(fb);
  unsigned long detectionTime = millis() - detectionStart;
  
  // Exibir descri√ß√£o
  Serial.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
  Serial.println("üéØ DESCRI√á√ÉO DA CENA:");
  Serial.println(description);
  Serial.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
  
  // Enviar para servidor
  unsigned long sendStart = millis();
  bool success = sendToServerWebSocket(description, fb, captureTime, detectionTime, millis() - sendStart);
  unsigned long sendTime = millis() - sendStart;
  
  // Liberar mem√≥ria
  esp_camera_fb_return(fb);
  
  // Calcular m√©tricas
  unsigned long totalTime = millis() - startTime;
  uint32_t freeHeapAfter = ESP.getFreeHeap();
  int32_t heapUsed = freeHeapBefore - freeHeapAfter;
  
  // Exibir estat√≠sticas de performance
  Serial.println("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚ö° PERFORMANCE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
  Serial.printf("‚îÇ ‚è±Ô∏è  Tempo Captura:    %4lu ms                        ‚îÇ\n", captureTime);
  Serial.printf("‚îÇ üîç Tempo Detec√ß√£o:    %4lu ms                        ‚îÇ\n", detectionTime);
  Serial.printf("‚îÇ üì§ Tempo Envio:       %4lu ms   [%s]           ‚îÇ\n", 
                sendTime, success ? "‚úÖ" : "‚ùå");
  Serial.printf("‚îÇ ‚è≤Ô∏è  Tempo Total:       %4lu ms                        ‚îÇ\n", totalTime);
  Serial.println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ üíæ MEM√ìRIA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
  Serial.printf("‚îÇ üß† Heap Livre:        %6d bytes                  ‚îÇ\n", freeHeapAfter);
  Serial.printf("‚îÇ üìä Heap Usado Ciclo:  %6d bytes                  ‚îÇ\n", heapUsed > 0 ? heapUsed : 0);
  Serial.printf("‚îÇ üìà Uso Mem√≥ria:       %3d%%                          ‚îÇ\n", 
                (int)((327680 - freeHeapAfter) * 100 / 327680));
  Serial.println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ üå°Ô∏è  SISTEMA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
  Serial.printf("‚îÇ üî• CPU Freq:          %3d MHz                       ‚îÇ\n", ESP.getCpuFreqMHz());
  Serial.printf("‚îÇ üì∂ WiFi RSSI:         %3d dBm                       ‚îÇ\n", WiFi.RSSI());
  Serial.printf("‚îÇ ‚ö° FPS Estimado:      %.2f fps                      ‚îÇ\n", 
                totalTime > 0 ? 1000.0 / totalTime : 0.0);
  Serial.println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
}

// ===== SETUP =====
void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(false);
  
  Serial.println("\n\n=== ESP32 INICIANDO ===");
  Serial.println("Aguardando estabiliza√ß√£o...");
  
  delay(2000); // Delay maior para estabilizar
  
  Serial.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  Serial.println("‚ïë  üëÅÔ∏è  SISTEMA DE VIS√ÉO PARA PCD      ‚ïë");
  Serial.println("‚ïë  Detec√ß√£o de Objetos ‚Üí Texto        ‚ïë");
  Serial.println("‚ïë  WebSocket Bidirectional            ‚ïë");
  Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
  
  Serial.printf("üîã Heap livre no in√≠cio: %d bytes\n", ESP.getFreeHeap());
  Serial.printf("‚ö° CPU: %d MHz\n\n", ESP.getCpuFreqMHz());
  
  // Inicializar c√¢mera
  Serial.println("üì∑ Tentando inicializar c√¢mera...");
  Serial.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
  
  if (!initCamera()) {
    Serial.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
    Serial.println("‚ùå ERRO CR√çTICO: C√¢mera n√£o inicializou!");
    Serial.println("");
    Serial.println("‚ö†Ô∏è  Poss√≠veis causas:");
    Serial.println("   1. C√¢mera n√£o conectada corretamente");
    Serial.println("   2. GPIOs incorretos");
    Serial.println("   3. C√¢mera defeituosa");
    Serial.println("   4. Falta de mem√≥ria");
    Serial.println("");
    Serial.println("üîÑ Sistema em modo seguro - SEM c√¢mera");
    Serial.println("   Continuar√° apenas com WiFi e servidor");
    Serial.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n");
    
    // N√ÉO reinicia - continua em modo seguro
    delay(3000);
  } else {
    Serial.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n");
  }
  
  // Conectar WiFi
  Serial.println("üì° Conectando ao WiFi...");
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  WiFi.setSleep(false);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    Serial.println("\n‚úÖ WiFi conectado!");
    Serial.print("üìç IP: ");
    Serial.println(WiFi.localIP());
    Serial.print("üì∂ RSSI: ");
    Serial.println(WiFi.RSSI());
    
    // Inicializar WebSocket
    Serial.println("\nüîå Conectando ao servidor WebSocket...");
    String serverURL = String("ws://") + serverIP + ":" + serverPort + "/vision";
    Serial.print("üåê URL: ");
    Serial.println(serverURL);
    
    socketIO.begin(serverIP, serverPort, "/socket.io/?EIO=4&transport=websocket");
    socketIO.onEvent(webSocketEvent);
    
    Serial.println("‚úÖ WebSocket configurado!");
  } else {
    wifiConnected = false;
    Serial.println("\n‚ö†Ô∏è  WiFi n√£o conectado (modo offline)");
  }
  
  // Informa√ß√µes do sistema
  Serial.println("\nüìä Informa√ß√µes do Sistema:");
  Serial.printf("üíæ PSRAM: %s\n", psramFound() ? "‚úÖ Dispon√≠vel" : "‚ùå N√£o dispon√≠vel");
  if(psramFound()) {
    Serial.printf("üî¢ PSRAM Total: %d bytes (%.2f MB)\n", 
                  ESP.getPsramSize(), ESP.getPsramSize() / 1048576.0);
    Serial.printf("‚úÖ PSRAM Livre: %d bytes (%.2f MB)\n", 
                  ESP.getFreePsram(), ESP.getFreePsram() / 1048576.0);
  }
  Serial.printf("üß† Heap Livre: %d bytes\n", ESP.getFreeHeap());
  Serial.printf("‚ö° CPU Freq: %d MHz\n", ESP.getCpuFreqMHz());
  Serial.printf("üì∑ Resolu√ß√£o: %s\n", psramFound() ? "320x240 (QVGA)" : "160x120 (QQVGA)");
  Serial.printf("‚è±Ô∏è  Intervalo de detec√ß√£o: %d ms\n", DETECTION_INTERVAL);
  
  Serial.println("\nüöÄ Sistema pronto para detectar objetos!");
  Serial.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n");
  
  delay(2000);
}

// ===== LOOP =====
void loop() {
  unsigned long currentTime = millis();
  
  // Manter WebSocket ativo
  socketIO.loop();
  
  // Executar detec√ß√£o a cada intervalo definido (somente se c√¢mera estiver OK e WebSocket conectado)
  if (cameraOK && websocketConnected && isRegistered && 
      currentTime - lastDetectionTime >= DETECTION_INTERVAL) {
    lastDetectionTime = currentTime;
    processFrame();
  } else if (!cameraOK && currentTime - lastDetectionTime >= 10000) {
    // Se c√¢mera n√£o est√° OK, exibe mensagem a cada 10 segundos
    lastDetectionTime = currentTime;
    Serial.println("‚ö†Ô∏è  Sistema em modo seguro - C√¢mera n√£o dispon√≠vel");
    Serial.printf("üß† Heap livre: %d bytes | ", ESP.getFreeHeap());
    Serial.printf("üì∂ WiFi: %s | ", wifiConnected ? "Conectado" : "Desconectado");
    Serial.printf("üîå WebSocket: %s\n", websocketConnected ? "Conectado" : "Desconectado");
  } else if (cameraOK && !isRegistered && websocketConnected && 
             currentTime - lastDetectionTime >= 5000) {
    // Tentar registrar novamente se n√£o estiver registrado
    lastDetectionTime = currentTime;
    Serial.println("‚ö†Ô∏è  Tentando registrar no servidor...");
    registerESP32();
  }
  
  // Verificar conex√£o WiFi
  if (WiFi.status() != WL_CONNECTED && wifiConnected) {
    wifiConnected = false;
    websocketConnected = false;
    isRegistered = false;
    Serial.println("‚ö†Ô∏è  WiFi desconectado!");
  } else if (WiFi.status() == WL_CONNECTED && !wifiConnected) {
    wifiConnected = true;
    Serial.println("‚úÖ WiFi reconectado!");
    
    // Reconectar WebSocket
    Serial.println("üîå Reconectando WebSocket...");
    socketIO.begin(serverIP, serverPort, "/socket.io/?EIO=4&transport=websocket");
  }
  
  delay(100);
}
